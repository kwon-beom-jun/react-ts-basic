/**
 * ──────────────────────────────────────────────
 * ⛵ React 17+ Automatic JSX Runtime 요약 메모
 * ──────────────────────────────────────────────
 *
 * 1. Classic Runtime  (React 16 이하)
 * ------------------------------------------------------------
 *  // Counter.jsx (컴파일 전)
 *  export default () => <h1>Hello</h1>;
 *
 *  // Babel/TS 트랜스파일 결과
 *  import React from 'react';
 *  export default () =>
 *    React.createElement('h1', null, 'Hello');
 *
 *    ▸ JSX → React.createElement(...)
 *    ▸ 식별자 React 가 필요하므로
 *       └─ 파일마다 `import React from 'react'` 필수
 *
 *
 * 2. Automatic Runtime (React 17 이상)
 * ------------------------------------------------------------
 *  // Counter.jsx (컴파일 전)
 *  export default () => <h1>Hello</h1>;
 *
 *  // Babel 7.9+ / TS 4.1+ 트랜스파일 결과
 *  import { jsx as _jsx } from 'react/jsx-runtime';
 *  export default () =>
 *     _jsx('h1', { children: 'Hello' });
 *
 *    ▸ JSX → jsx/jsxs 함수 호출
 *    ▸ 컴파일러가 react/jsx-runtime 에서
 *      필요한 함수만 “자동 import”
 *    ▸ 따라서 직접 `import React …` 작성 불필요
 *
 *
 * 3. 장점
 * ------------------------------------------------------------
 *  ▸ 불필요한 default import 제거 → 파일이 깔끔
 *  ▸ React 네임스페이스 사용 안 하면
 *    번들러가 해당 코드를 트리 셰이킹 가능
 *  ▸ CRA 4+, Next.js 10+, Vite 2+ 등 기본 활성화
 */
import ReactDOM from 'react-dom/client'
import * as D from './data'

/**
 * ─────────────────────────────────────────────────────────────
 * 🌟 JSX란? (JavaScript XML) — React의 핵심 개념 요약
 * ─────────────────────────────────────────────────────────────
 *
 * 📌 1. JSX는 무엇의 줄임말인가요?
 *   ▸ JSX = JavaScript + XML
 *   ▸ 자바스크립트 안에서 HTML 태그처럼 작성할 수 있게 해주는 문법
 *
 * 📌 2. 왜 JSX를 쓰나요?
 *   ▸ HTML을 문자열로 쓰지 않고, 코드처럼 "구조적이고 안전하게 UI"를 표현할 수 있음
 *   ▸ 동적 데이터 바인딩 (변수·함수)와 조합이 쉬움
 *     예) <h1>{user.name}님, 환영합니다!</h1>
 *
 * 📌 3. JSX는 브라우저가 이해할 수 있나요?
 *   ✘ 아니요. 브라우저는 JSX를 직접 이해하지 못합니다.
 *   ✔ JSX는 "React.createElement() 함수"로 변환되어 실행됩니다.
 *
 *   예) JSX 코드
 *       const el = <h1>Hello</h1>;
 *
 *       트랜스파일 결과 (React 16 이하)
 *       const el = React.createElement('h1', null, 'Hello');
 *
 * 📌 4. JSX 특징
 *   ▸ 모든 JSX는 반드시 하나의 부모 요소로 감싸야 함
 *     ✘ return <h1></h1><p></p> ← 오류
 *     ✔ return <div><h1></h1><p></p></div>
 *   ▸ JS 표현식은 {} 중괄호로 감쌈
 *     ✔ <p>{user.name}</p>
 *   ▸ HTML과 다른 JSX 속성
 *     - class → className
 *     - for → htmlFor
 *
 * 📌 5. JSX 사용 시 필요한 것 (React 17 기준)
 *   ▸ React 16 이하: 반드시 `import React from 'react'` 필요
 *   ▸ React 17 이상: Babel/TS가 자동으로 처리 (Automatic Runtime)
 *
 * 📌 6. JSX 파일 확장자
 *   ▸ .jsx (JS + JSX) 또는 .tsx (TypeScript + JSX)
 * 
 * 
 * JSX가 하는 일
 * ------------------------------------------------------------
 *   · JSX 코드는 컴파일 시 `React.createElement()`(React 16↓)
 *     또는 `jsx()` (React 17+) 호출로 변환된다.
 *      └─ 반환값 = “가상 DOM 노드(React 엘리먼트)”
 *   · 그래서 JSX 중괄호 `{ … }` 안에는
 *     화면에 삽입할 “값”이어야 하며  
 *     React가 이해할 수 있는 타입으로 평가돼야 한다.
 *     (문자열·숫자·ReactElement·배열·null/undefined·boolean)
 *
 * ─────────────────────────────────────────────────────────────
 * 
 * ✅ 요약:
 * JSX는 "HTML 같은 문법을 자바스크립트 코드 안에서 자연스럽게 작성"하게 해 주는 문법.
 * 리액트에서 컴포넌트를 선언하거나 UI를 표현할 때 핵심적으로 사용됩니다.
 * ─────────────────────────────────────────────────────────────
 */

/**
 * ─────────────────────────────────────────────────────────────
 * 🌼 JSX 중괄호 { … } 안에서 “표현식만 써야 하는” 이유 총정리
 * ─────────────────────────────────────────────────────────────
 *
 * 1. 기본 용어 ─ 표현식 vs 실행문(문장)
 * ------------------------------------------------------------
 * ■ 표현식(Expression)
 *    · 평가-되면 “값”이 생기는 코드 조각
 *    · 예: 2 + 3, user.name, a ? b : c, func()
 *
 * ■ 실행문(Statement)
 *    · 동작(제어/선언)을 수행하고 값을 돌려주지 않음
 *    · 예: if (x) {…}, for (…) {…}, const v = 1;
 *
 * 2. JSX 규칙
 * ------------------------------------------------------------
 *    · JSX 의 { … } 안에는 “값을 주는 코드”만 허용 ⇒ 표현식만 O
 *    · 실행문은 값을 안 돌려서 JSX가 렌더할 수 없음 ⇒ 문장 X
 *      ( 실행문(if, for 등)을 중괄호 “안에 바로” 넣을 순 없음 ❌)
 *
 *      <Box>
 *        { user.name }             // ✅ 표현식 → 문자열 값
 *        { flag && <Badge/> }      // ✅ 표현식 → <Badge/> 또는 false
 *        { list.map(i => <Li/>) }  // ✅ 표현식 → 배열 값
 *
 *        { if, for 등 실행문은 직접 사용 불가 ❌ }
 *        { if (flag) { return <p>ON</p>; } }
 *      </Box>
 *
 * 3. 실행문이 필요할 때 대안
 * ------------------------------------------------------------
 *    · 조건부   : flag && <A/>  또는  flag ? <A/> : null
 *    · 반복     : list.map(item => <Li … />)
 *    · 복잡로직 : IIFE 사용
 *        {(() => {
 *            if (flag) return <A/>;
 *            return <B/>;
 *        })()}
 *
 * 4. “return 없는 값 반환”이란?
 * ------------------------------------------------------------
 *    · 화살표 함수 표현식 본문:  n => n * 2   // 값(표현식) 자동 반환
 *    · 중괄호 블록 본문    :  n => { return n*2; } // return 필요
 *    · 표현식 특성(값을 만든다)을 빌려 “return을 생략할 수 있다”는 뜻
 *
 * 5. TypeScript·ESNext와의 관계
 * ------------------------------------------------------------
 *    · 표현식/문장 개념은 순수 자바스크립트(ES2015) 규칙
 *    · TypeScript는 JS 상위 집합이므로 그대로 지원할 뿐, 전용 기능 아님
 * 
 * ─────────────────────────────────────────────────────────────
 * 🔑 기억 포인트
 *    1) { … } 안엔 ‘값을 내는 표현식’만!
 *    2) 실행문이 필요하면 표현식 형태(&&, ? :, map, IIFE)로 바꿔라.
 * ─────────────────────────────────────────────────────────────
 */


// ────────────────────────────────────────────────────────────────
// ⛵ 1) children  ▶️  랜덤 카드 3개를 담은 ReactElement[] 생성
//      - D.makeArray(3)  : [null, null, null] 길이 3 배열
//      - map()            : 각 요소 → <div> 카드로 변환
//      - key={index}      : 리스트 재조정 시 React가 항목 식별
// ────────────────────────────────────────────────────────────────
const children = D.makeArray(3).map((_, index) => (
  <div key={index}>
    {/* Chance·picsum 기반 랜덤 더미 데이터 */}
    <p>{D.randomId()}</p>           {/* ① 페이스북 스타일 15자리 ID */}
    <p>{D.randomName()}</p>         {/* ② 무작위 이름 */}
    <p>{D.randomJobTitle()}</p>     {/* ③ 직함(Software Eng. 등) */}
    <p>{D.randomSentence()}</p>     {/* ④ 5단어 짧은 문장 */}
    <img                             /* ⑤ 정사각형 랜덤 아바타 */
      src={D.randomAvatar()}
      width={100}
      height={100}
      alt="avatar"
    />
  </div>
));


// ────────────────────────────────────────────────────────────────
// 🌳 2) rootVirtualDOM  ▶️  화면에 렌더할 “최상위 가상 DOM”
//      - <div>{children}</div> 하나여야 React가 문제없이 마운트
//      - 단일 루트 가상 DOM 생성 (React는 루트가 하나여야 마운트 가능)
//        에러)
//          root.render(
//            <h1>Hello</h1>
//            <p>World</p>
//          );
// ────────────────────────────────────────────────────────────────
// const rootVirtualDOM = <div>{children}</div>;
const rootVirtualDOM = <>{children}</>;


// ────────────────────────────────────────────────────────────────
// 🪄 3) ReactDOM Root 생성 (React 18 방식)
//      - #root 컨테이너를 찾아 동시성 모드(createRoot)로 초기화
// ────────────────────────────────────────────────────────────────
const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);


// ────────────────────────────────────────────────────────────────
// 🚀 4) 실제 렌더링
//      - 가상 DOM 트리를 diff → 실제 브라우저 DOM 패치
// ────────────────────────────────────────────────────────────────
root.render(rootVirtualDOM);
